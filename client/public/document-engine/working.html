<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Engine</title>
    <!-- KaTeX for mathematical rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    <script>
      // Global function for LaTeX rendering
      window.renderMathInElement = function(element, options) {
        if (typeof renderMathInElement !== 'undefined') {
          return renderMathInElement(element, options);
        }
      };
      
      // Auto-render LaTeX in the document
      document.addEventListener('DOMContentLoaded', function() {
        if (typeof renderMathInElement !== 'undefined') {
          renderMathInElement(document.body, {
            delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\[', right: '\\]', display: true},
              {left: '\\(', right: '\\)', display: false}
            ],
            throwOnError: false,
            errorColor: '#cc0000'
          });
        }
      });
      
      // Handle INSERT_HTML messages for LaTeX content
      window.addEventListener('message', function(event) {
        if (event.data.type === 'INSERT_HTML') {
          const html = event.data.data.html;
          console.log('Received INSERT_HTML:', html);
          
          // Insert HTML content at cursor position
          const selection = window.getSelection();
          if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const div = document.createElement('div');
            div.innerHTML = html;
            range.deleteContents();
            range.insertNode(div);
            
            // Trigger LaTeX rendering after insertion with comprehensive macros
            setTimeout(() => {
              if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(div, {
                  delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\[', right: '\\]', display: true},
                    {left: '\\(', right: '\\)', display: false}
                  ],
                  throwOnError: false,
                  errorColor: '#cc0000',
                  macros: {
                    // Physics macros
                    "\\vec": "\\mathbf{#1}",
                    "\\div": "\\text{div}",
                    "\\curl": "\\text{curl}",
                    "\\grad": "\\nabla",
                    "\\force": "\\mathbf{F}",
                    "\\moment": "\\mathbf{M}",
                    "\\velocity": "\\mathbf{v}",
                    "\\acceleration": "\\mathbf{a}",
                    "\\momentum": "\\mathbf{p}",
                    "\\energy": "E",
                    "\\kinetic": "K",
                    "\\potential": "U",
                    "\\work": "W",
                    "\\power": "P",
                    "\\pressure": "P",
                    "\\density": "\\rho",
                    "\\temperature": "T",
                    "\\entropy": "S",
                    "\\enthalpy": "H",
                    "\\heat": "Q",
                    
                    // Chemistry macros
                    "\\chem": "\\text{#1}",
                    "\\reaction": "\\ce{#1}",
                    "\\molecule": "\\ce{#1}",
                    "\\concentration": "[#1]",
                    "\\equilibrium": "\\rightleftharpoons",
                    "\\catalyst": "\\text{catalyst}",
                    "\\activation": "E_a",
                    "\\rate": "k",
                    "\\order": "n",
                    
                    // Engineering macros
                    "\\stress": "\\sigma",
                    "\\strain": "\\varepsilon",
                    "\\modulus": "E",
                    "\\poisson": "\\nu",
                    "\\shear": "\\tau",
                    "\\torsion": "T",
                    "\\bending": "M",
                    "\\deflection": "\\delta",
                    "\\frequency": "f",
                    "\\wavelength": "\\lambda",
                    "\\amplitude": "A",
                    "\\phase": "\\phi",
                    "\\impedance": "Z",
                    "\\resistance": "R",
                    "\\capacitance": "C",
                    "\\inductance": "L",
                    "\\voltage": "V",
                    "\\current": "I",
                    
                    // Calculus macros
                    "\\derivative": "\\frac{d}{dx}",
                    "\\partial": "\\frac{\\partial}{\\partial}",
                    "\\integral": "\\int",
                    "\\definite": "\\int_{#1}^{#2}",
                    "\\limit": "\\lim",
                    "\\series": "\\sum",
                    "\\product": "\\prod",
                    "\\convergence": "\\to",
                    "\\infinity": "\\infty",
                    "\\differential": "d",
                    "\\partialdiff": "\\partial",
                    
                    // Mathematical macros
                    "\\abs": "|#1|",
                    "\\norm": "\\|#1\\|",
                    "\\set": "\\{#1\\}",
                    "\\seq": "(#1)",
                    "\\mat": "\\begin{pmatrix} #1 \\end{pmatrix}",
                    "\\det": "\\det",
                    "\\tr": "\\text{tr}",
                    "\\rank": "\\text{rank}",
                    "\\nullity": "\\text{nullity}",
                    "\\eigenvalue": "\\lambda",
                    "\\eigenvector": "\\mathbf{v}",
                    "\\transpose": "T",
                    "\\inverse": "^{-1}",
                    "\\conjugate": "\\overline{#1}",
                    "\\real": "\\text{Re}",
                    "\\imaginary": "\\text{Im}",
                    "\\mod": "\\bmod",
                    "\\gcd": "\\gcd",
                    "\\lcm": "\\text{lcm}",
                    "\\factorial": "!",
                    "\\binomial": "\\binom{#1}{#2}",
                    "\\permutation": "P(#1,#2)",
                    "\\combination": "C(#1,#2)"
                  }
                });
                console.log('LaTeX rendering completed for formula sheet');
              }
            }, 200);
          }
        }
      });
    </script>

    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Times New Roman', serif;
            background-color: #f5f5f5;
        }
        
        .pages-container {
            max-width: 8.5in;
            margin: 0 auto;
        }
        
        .page {
            width: 8.5in;
            height: 11in;
            margin: 20px auto;
            background: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: relative;
            padding: 0;
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }
        
        .page-number {
            position: absolute;
            bottom: 0.5in;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10pt;
            color: #666;
        }
        
        .editor {
            width: 6.5in;  /* 8.5in - 2in for margins */
            height: 9in;   /* 11in - 2in for margins */
            margin: 1in;   /* 1in margin on all sides */
            border: none;
            outline: none;
            font-family: 'Times New Roman', serif;
            font-size: 12pt;
            line-height: 1.5;
            resize: none;
            background: transparent;
            overflow: hidden;
            padding: 0;
        }
        
        /* LaTeX rendering styles */
        .katex {
            font-size: 1em !important;
            line-height: 1.2 !important;
        }
        
        .katex-display {
            margin: 0.5em 0 !important;
        }
        
        /* Ensure LaTeX renders properly in the document */
        .page .katex {
            font-family: 'KaTeX_Main', 'Times New Roman', serif !important;
        }
        
        /* Print styles - only show document pages when printing */
        @media print {
            body {
                margin: 0;
                padding: 0;
                background: white;
            }
            
            .pages-container {
                margin: 0;
                padding: 0;
            }
            
            .page {
                margin: 0;
                padding: 0;
                border: none;
                box-shadow: none;
                page-break-after: always;
                page-break-inside: avoid;
                width: 8.5in;
                height: 11in;
                display: flex;
                align-items: flex-start;
                justify-content: center;
            }
            
            .page:last-child {
                page-break-after: auto;
            }
            
            .editor {
                border: none;
                background: transparent;
                color: black;
                font-family: 'Times New Roman', serif;
                font-size: 12pt;
                line-height: 1.5;
                margin: 1in;
                padding: 0;
                width: 6.5in;
                height: 9in;
                overflow: visible;
                resize: none;
            }
            
            .page-number {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="pages-container" id="pagesContainer">
        <div class="page">
                            <textarea class="editor" id="editor1" data-page="1"></textarea>
            <div class="page-number">Page 1</div>
        </div>
    </div>

    <script>
        let pages = [];
        let currentPageIndex = 0;
        const pagesContainer = document.getElementById('pagesContainer');
        
        // Initialize pages
        function initializePages() {
            const firstEditor = document.getElementById('editor1');
            pages = [firstEditor];
            setupEditorEvents(firstEditor, 0);
            firstEditor.focus();
            
            // Send ready message to parent
            sendMessageToParent('DOCUMENT_ENGINE_READY', {});
        }
        
        // Send message to parent window
        function sendMessageToParent(type, data) {
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({ type, data }, '*');
            }
        }
        
        // Send document data to parent
        function sendDocumentData() {
            const stats = getStats();
            const content = getAllText();
            const contentHeight = pagesContainer.scrollHeight;
            
            sendMessageToParent('DOCUMENT_DATA', {
                title: 'Document',
                content: content,
                stats: {
                    wordCount: stats.words,
                    charCount: stats.characters,
                    lineCount: stats.lines,
                    pageCount: stats.pages
                },
                contentHeight: contentHeight
            });
        }
        
        // Create a new page
        function createNewPage() {
            const pageNumber = pages.length + 1;
            const pageDiv = document.createElement('div');
            pageDiv.className = 'page';
            
            pageDiv.innerHTML = `
                <textarea class="editor" id="editor${pageNumber}" data-page="${pageNumber}"></textarea>
                <div class="page-number">Page ${pageNumber}</div>
            `;
            
            pagesContainer.appendChild(pageDiv);
            
            const newEditor = pageDiv.querySelector('.editor');
            pages.push(newEditor);
            setupEditorEvents(newEditor, pageNumber - 1);
            
            console.log(`Created page ${pageNumber}`);
            sendDocumentData();
            return newEditor;
        }
        
        // Setup events for an editor
        function setupEditorEvents(editor, pageIndex) {
            // Handle input and check for overflow/underflow
            editor.addEventListener('input', function(e) {
                checkForOverflow(editor, pageIndex);
                checkForUnderflow(editor, pageIndex);
                sendDocumentData();
                
                // Trigger LaTeX rendering on input
                setTimeout(() => {
                    if (typeof renderMathInElement !== 'undefined') {
                        renderMathInElement(editor.parentElement, {
                            delimiters: [
                                {left: '$$', right: '$$', display: true},
                                {left: '$', right: '$', display: false},
                                {left: '\\[', right: '\\]', display: true},
                                {left: '\\(', right: '\\)', display: false}
                            ],
                            throwOnError: false,
                            errorColor: '#cc0000'
                        });
                    }
                }, 100);
            });
            
            // Handle keyboard navigation between pages
            editor.addEventListener('keydown', function(e) {
                handleKeyboardNavigation(e, editor, pageIndex);
            });
            
            // Handle focus
            editor.addEventListener('focus', function() {
                currentPageIndex = pageIndex;
            });
            
            // Handle text selection and cutting/copying
            editor.addEventListener('cut', function(e) {
                setTimeout(() => {
                    checkForUnderflow(editor, pageIndex);
                    sendDocumentData();
                }, 10);
            });
            
            // Handle paste operations
            editor.addEventListener('paste', function(e) {
                setTimeout(() => {
                    checkForOverflow(editor, pageIndex);
                    setTimeout(() => {
                        checkForUnderflow(editor, pageIndex);
                        sendDocumentData();
                    }, 50);
                }, 10);
            });
            
            editor.addEventListener('keyup', function(e) {
                if (e.key === 'Backspace' || e.key === 'Delete') {
                    checkForUnderflow(editor, pageIndex);
                    sendDocumentData();
                }
            });
        }
        
        // Check if current page has overflowed
        function checkForOverflow(editor, pageIndex) {
            if (editor.scrollHeight > editor.clientHeight) {
                handleOverflow(editor, pageIndex);
            }
        }
        
        // Handle text overflow to next page using binary search
        function handleOverflow(editor, pageIndex) {
            const text = editor.value;
            const cursorPos = editor.selectionStart;
            
            const breakPoint = findOverflowBreakPoint(editor, text);
            
            if (breakPoint < text.length) {
                const currentPageContent = text.substring(0, breakPoint);
                const overflowContent = text.substring(breakPoint);
                
                editor.value = currentPageContent;
                
                let nextEditor;
                if (pageIndex + 1 < pages.length) {
                    nextEditor = pages[pageIndex + 1];
                    nextEditor.value = overflowContent + (nextEditor.value ? nextEditor.value : '');
                } else {
                    nextEditor = createNewPage();
                    nextEditor.value = overflowContent;
                }
                
                if (cursorPos > breakPoint) {
                    nextEditor.focus();
                    const newCursorPos = cursorPos - breakPoint;
                    nextEditor.setSelectionRange(newCursorPos, newCursorPos);
                    currentPageIndex = pageIndex + 1;
                } else {
                    editor.focus();
                    editor.setSelectionRange(cursorPos, cursorPos);
                }
                
                setTimeout(() => {
                    checkForOverflow(nextEditor, pageIndex + 1);
                }, 10);
            }
        }
        
        // Binary search to find exact character position where content overflows
        function findOverflowBreakPoint(editor, text) {
            let left = 0;
            let right = text.length;
            let lastValidPosition = text.length;
            
            const originalValue = editor.value;
            const originalScrollTop = editor.scrollTop;
            
            while (left < right) {
                const mid = Math.floor((left + right) / 2);
                const testContent = text.substring(0, mid);
                
                editor.value = testContent;
                editor.scrollTop = 0;
                
                if (editor.scrollHeight <= editor.clientHeight) {
                    lastValidPosition = mid;
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
            
            const nearBreakPoint = findNearestBreakPoint(text, lastValidPosition);
            
            editor.value = originalValue;
            editor.scrollTop = originalScrollTop;
            
            return nearBreakPoint;
        }
        
        // Find the nearest word or line break near the target position
        function findNearestBreakPoint(text, targetPosition) {
            if (targetPosition >= text.length - 5) {
                return targetPosition;
            }
            
            for (let i = targetPosition; i >= Math.max(0, targetPosition - 20); i--) {
                if (text[i] === '\n') {
                    return i + 1;
                }
            }
            
            for (let i = targetPosition; i >= Math.max(0, targetPosition - 10); i--) {
                if (text[i] === ' ') {
                    return i + 1;
                }
            }
            
            return targetPosition;
        }
        
        // Check if current page has too little content and can pull from next page
        function checkForUnderflow(editor, pageIndex) {
            if (pageIndex + 1 >= pages.length) return;
            
            const currentText = editor.value;
            const nextEditor = pages[pageIndex + 1];
            const nextText = nextEditor.value;
            
            if (nextText.trim() === '') {
                removeEmptyPage(pageIndex + 1);
                return;
            }
            
            const currentHeight = editor.scrollHeight;
            const availableHeight = editor.clientHeight;
            const spaceRatio = currentHeight / availableHeight;
            
            if (spaceRatio < 0.4) {
                pullContentFromNextPage(editor, pageIndex);
            }
        }
        
        // Pull content from next page to current page
        function pullContentFromNextPage(editor, pageIndex) {
            const nextEditor = pages[pageIndex + 1];
            if (!nextEditor) return;
            
            const nextText = nextEditor.value;
            if (!nextText) return;
            
            const currentText = editor.value;
            const maxPullAmount = findMaxPullAmount(editor, currentText, nextText);
            
            if (maxPullAmount > 0) {
                const contentToPull = nextText.substring(0, maxPullAmount);
                const remainingNextContent = nextText.substring(maxPullAmount);
                
                const currentCursorPos = editor.selectionStart;
                const nextCursorPos = nextEditor.selectionStart;
                
                editor.value = currentText + (currentText ? '\n' : '') + contentToPull;
                nextEditor.value = remainingNextContent;
                
                if (currentPageIndex === pageIndex) {
                    editor.focus();
                    editor.setSelectionRange(currentCursorPos, currentCursorPos);
                } else if (currentPageIndex === pageIndex + 1) {
                    nextEditor.focus();
                    const newCursorPos = Math.max(0, nextCursorPos - contentToPull.length - 1);
                    nextEditor.setSelectionRange(newCursorPos, newCursorPos);
                }
                
                if (nextEditor.value.trim() === '') {
                    removeEmptyPage(pageIndex + 1);
                } else {
                    setTimeout(() => {
                        checkForUnderflow(nextEditor, pageIndex + 1);
                    }, 10);
                }
            }
        }
        
        // Find maximum amount of content we can pull from next page
        function findMaxPullAmount(editor, currentText, nextText) {
            let left = 0;
            let right = nextText.length;
            let maxPull = 0;
            
            const originalValue = editor.value;
            const originalScrollTop = editor.scrollTop;
            
            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                const testContent = nextText.substring(0, mid);
                const combinedContent = currentText + (currentText ? '\n' : '') + testContent;
                
                editor.value = combinedContent;
                editor.scrollTop = 0;
                
                if (editor.scrollHeight <= editor.clientHeight) {
                    maxPull = mid;
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            
            const breakPoint = findNearestBreakPoint(nextText, maxPull);
            
            editor.value = originalValue;
            editor.scrollTop = originalScrollTop;
            
            return Math.min(breakPoint, maxPull);
        }
        
        // Remove an empty page
        function removeEmptyPage(pageIndex) {
            if (pageIndex === 0 || pageIndex >= pages.length) return;
            
            const pageElement = pages[pageIndex].parentElement;
            pageElement.remove();
            pages.splice(pageIndex, 1);
            
            for (let i = pageIndex; i < pages.length; i++) {
                const pageNumber = i + 1;
                pages[i].id = `editor${pageNumber}`;
                pages[i].setAttribute('data-page', pageNumber);
                const pageNumberElement = pages[i].parentElement.querySelector('.page-number');
                if (pageNumberElement) {
                    pageNumberElement.textContent = `Page ${pageNumber}`;
                }
                
                setupEditorEvents(pages[i], i);
            }
            
            if (currentPageIndex >= pageIndex) {
                currentPageIndex = Math.max(0, currentPageIndex - 1);
            }
            
            console.log(`Removed empty page, now have ${pages.length} pages`);
            sendDocumentData();
        }
        
        // Handle keyboard navigation between pages
        function handleKeyboardNavigation(e, editor, pageIndex) {
            const cursorPos = editor.selectionStart;
            const text = editor.value;
            
            if (e.key === 'ArrowDown' && cursorPos === text.length) {
                if (pageIndex + 1 < pages.length) {
                    e.preventDefault();
                    pages[pageIndex + 1].focus();
                    pages[pageIndex + 1].setSelectionRange(0, 0);
                    currentPageIndex = pageIndex + 1;
                }
            } else if (e.key === 'ArrowUp' && cursorPos === 0) {
                if (pageIndex > 0) {
                    e.preventDefault();
                    const prevEditor = pages[pageIndex - 1];
                    prevEditor.focus();
                    prevEditor.setSelectionRange(prevEditor.value.length, prevEditor.value.length);
                    currentPageIndex = pageIndex - 1;
                }
            }
        }
        
        // API Functions
        function getAllText() {
            return pages.map(editor => editor.value).join('\n');
        }
        
        function setContent(content) {
            while (pages.length > 1) {
                removeEmptyPage(1);
            }
            
            pages[0].value = content;
            pages[0].focus();
            
            setTimeout(() => {
                checkForOverflow(pages[0], 0);
                sendDocumentData();
            }, 10);
        }
        
        function getPageCount() {
            return pages.length;
        }
        
        function printDocument() {
            pages.forEach((editor, index) => {
                editor.style.height = 'auto';
                editor.style.minHeight = '9in';
                editor.style.overflow = 'visible';
                editor.style.border = 'none';
                editor.style.outline = 'none';
                editor.style.boxShadow = 'none';
            });
            
            setTimeout(() => {
                window.print();
                
                setTimeout(() => {
                    pages.forEach(editor => {
                        editor.style.height = '9in';
                        editor.style.minHeight = '';
                        editor.style.overflow = 'hidden';
                        editor.style.border = '';
                        editor.style.outline = '';
                        editor.style.boxShadow = '';
                    });
                    sendMessageToParent('PRINT_COMPLETE', {});
                }, 200);
            }, 100);
        }
        
        function getStats() {
            const allText = getAllText();
            const words = allText.trim() ? allText.trim().split(/\s+/).length : 0;
            const chars = allText.length;
            const lines = allText.split('\n').length;
            
            return {
                words: words,
                characters: chars,
                lines: lines,
                pages: pages.length
            };
        }
        
        function focusPage(pageNumber) {
            if (pageNumber >= 1 && pageNumber <= pages.length) {
                pages[pageNumber - 1].focus();
                currentPageIndex = pageNumber - 1;
            }
        }
        
        // Listen for messages from parent
        window.addEventListener('message', function(event) {
            const { type, data } = event.data;
            
            switch (type) {
                case 'PRINT_DOCUMENT':
                    printDocument();
                    break;
                case 'GET_DOCUMENT':
                    sendDocumentData();
                    break;
                case 'SET_CONTENT':
                    setContent(data.content || '');
                    break;
                case 'CLEAR_CONTENT':
                    setContent('');
                    break;
                case 'INSERT_TEXT':
                    if (data.text && pages[currentPageIndex]) {
                        // Insert text at cursor position
                        const editor = pages[currentPageIndex];
                        const cursorPos = editor.selectionStart;
                        const textBefore = editor.value.substring(0, cursorPos);
                        const textAfter = editor.value.substring(editor.selectionEnd);
                        
                        // Insert the text
                        editor.value = textBefore + data.text + textAfter;
                        editor.setSelectionRange(cursorPos + data.text.length, cursorPos + data.text.length);
                        
                        // Trigger LaTeX rendering after insertion
                        setTimeout(() => {
                            if (typeof renderMathInElement !== 'undefined') {
                                renderMathInElement(editor.parentElement, {
                                    delimiters: [
                                        {left: '$$', right: '$$', display: true},
                                        {left: '$', right: '$', display: false},
                                        {left: '\\[', right: '\\]', display: true},
                                        {left: '\\(', right: '\\)', display: false}
                                    ],
                                    throwOnError: false,
                                    errorColor: '#cc0000',
                                    macros: {
                                        // Physics macros
                                        "\\vec": "\\mathbf{#1}",
                                        "\\div": "\\text{div}",
                                        "\\curl": "\\text{curl}",
                                        "\\grad": "\\nabla",
                                        "\\force": "\\mathbf{F}",
                                        "\\moment": "\\mathbf{M}",
                                        "\\velocity": "\\mathbf{v}",
                                        "\\acceleration": "\\mathbf{a}",
                                        "\\momentum": "\\mathbf{p}",
                                        "\\energy": "E",
                                        "\\kinetic": "K",
                                        "\\potential": "U",
                                        "\\work": "W",
                                        "\\power": "P",
                                        "\\pressure": "P",
                                        "\\density": "\\rho",
                                        "\\temperature": "T",
                                        "\\entropy": "S",
                                        "\\enthalpy": "H",
                                        "\\heat": "Q"
                                    }
                                });
                                console.log('LaTeX rendering completed for text content');
                            }
                        }, 200);
                        
                        checkForOverflow(editor, currentPageIndex);
                        sendDocumentData();
                    }
                    break;
                case 'FORMAT_TEXT':
                    // Enhanced formatting support
                    if (data.command && pages[currentPageIndex]) {
                        const editor = pages[currentPageIndex];
                        const start = editor.selectionStart;
                        const end = editor.selectionEnd;
                        const selectedText = editor.value.substring(start, end);
                        
                        if (selectedText) {
                            let formattedText = selectedText;
                            
                            // Apply formatting based on command
                            switch(data.command) {
                                case 'bold':
                                    formattedText = `**${selectedText}**`;
                                    break;
                                case 'italic':
                                    formattedText = `*${selectedText}*`;
                                    break;
                                case 'underline':
                                    formattedText = `__${selectedText}__`;
                                    break;
                                case 'strikethrough':
                                    formattedText = `~~${selectedText}~~`;
                                    break;
                                default:
                                    // For other commands, try execCommand
                                    editor.focus();
                                    try {
                                        document.execCommand(data.command);
                                    } catch (e) {
                                        console.log('Format command not supported:', data.command);
                                    }
                                    break;
                            }
                            
                            // Replace selected text with formatted version
                            if (formattedText !== selectedText) {
                                const newText = editor.value.substring(0, start) + formattedText + editor.value.substring(end);
                                editor.value = newText;
                                editor.setSelectionRange(start, start + formattedText.length);
                                checkForOverflow(editor, currentPageIndex);
                                sendDocumentData();
                            }
                        }
                    }
                    break;
                case 'SET_FONT':
                    // Set font family or size
                    if (data.fontFamily && pages[currentPageIndex]) {
                        pages[currentPageIndex].style.fontFamily = data.fontFamily;
                        sendDocumentData();
                    }
                    if (data.fontSize && pages[currentPageIndex]) {
                        pages[currentPageIndex].style.fontSize = `${data.fontSize}pt`;
                        checkForOverflow(pages[currentPageIndex], currentPageIndex);
                        sendDocumentData();
                    }
                    break;
            }
        });
        
        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializePages();
            console.log('Document Engine initialized and ready');
            
            // Initialize KaTeX auto-render
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false,
                    errorColor: '#cc0000',
                    macros: {
                        // Physics macros
                        "\\vec": "\\mathbf{#1}",
                        "\\div": "\\text{div}",
                        "\\curl": "\\text{curl}",
                        "\\grad": "\\nabla",
                        "\\force": "\\mathbf{F}",
                        "\\moment": "\\mathbf{M}",
                        "\\velocity": "\\mathbf{v}",
                        "\\acceleration": "\\mathbf{a}",
                        "\\momentum": "\\mathbf{p}",
                        "\\energy": "E",
                        "\\kinetic": "K",
                        "\\potential": "U",
                        "\\work": "W",
                        "\\power": "P",
                        "\\pressure": "P",
                        "\\density": "\\rho",
                        "\\temperature": "T",
                        "\\entropy": "S",
                        "\\enthalpy": "H",
                        "\\heat": "Q",
                        
                        // Chemistry macros
                        "\\chem": "\\text{#1}",
                        "\\reaction": "\\ce{#1}",
                        "\\molecule": "\\ce{#1}",
                        "\\concentration": "[#1]",
                        "\\equilibrium": "\\rightleftharpoons",
                        "\\catalyst": "\\text{catalyst}",
                        "\\heat": "\\Delta H",
                        "\\entropy": "\\Delta S",
                        "\\gibbs": "\\Delta G",
                        "\\activation": "E_a",
                        "\\rate": "k",
                        "\\order": "n",
                        
                        // Engineering macros
                        "\\stress": "\\sigma",
                        "\\strain": "\\varepsilon",
                        "\\modulus": "E",
                        "\\poisson": "\\nu",
                        "\\shear": "\\tau",
                        "\\torsion": "T",
                        "\\bending": "M",
                        "\\deflection": "\\delta",
                        "\\frequency": "f",
                        "\\wavelength": "\\lambda",
                        "\\amplitude": "A",
                        "\\phase": "\\phi",
                        "\\impedance": "Z",
                        "\\resistance": "R",
                        "\\capacitance": "C",
                        "\\inductance": "L",
                        "\\voltage": "V",
                        "\\current": "I",
                        "\\power": "P",
                        "\\energy": "E",
                        
                        // Calculus macros
                        "\\derivative": "\\frac{d}{dx}",
                        "\\partial": "\\frac{\\partial}{\\partial}",
                        "\\integral": "\\int",
                        "\\definite": "\\int_{#1}^{#2}",
                        "\\limit": "\\lim",
                        "\\series": "\\sum",
                        "\\product": "\\prod",
                        "\\convergence": "\\to",
                        "\\infinity": "\\infty",
                        "\\differential": "d",
                        "\\partialdiff": "\\partial",
                        
                        // Mathematical macros
                        "\\abs": "|#1|",
                        "\\norm": "\\|#1\\|",
                        "\\set": "\\{#1\\}",
                        "\\seq": "(#1)",
                        "\\mat": "\\begin{pmatrix} #1 \\end{pmatrix}",
                        "\\det": "\\det",
                        "\\tr": "\\text{tr}",
                        "\\rank": "\\text{rank}",
                        "\\nullity": "\\text{nullity}",
                        "\\eigenvalue": "\\lambda",
                        "\\eigenvalue": "\\lambda",
                        "\\eigenvector": "\\mathbf{v}",
                        "\\transpose": "T",
                        "\\inverse": "^{-1}",
                        "\\conjugate": "\\overline{#1}",
                        "\\real": "\\text{Re}",
                        "\\imaginary": "\\text{Im}",
                        "\\mod": "\\bmod",
                        "\\gcd": "\\gcd",
                        "\\lcm": "\\text{lcm}",
                        "\\factorial": "!",
                        "\\binomial": "\\binom{#1}{#2}",
                        "\\permutation": "P(#1,#2)",
                        "\\combination": "C(#1,#2)"
                    }
                });
                console.log('KaTeX auto-render initialized with comprehensive macros');
                
                // Set up periodic re-rendering for dynamic content
                setInterval(() => {
                    renderMathInElement(document.body, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false},
                            {left: '\\[', right: '\\]', display: true},
                            {left: '\\(', right: '\\)', display: false}
                        ],
                        throwOnError: false,
                        errorColor: '#cc0000'
                    });
                }, 2000); // Re-render every 2 seconds
            }
        });
        
        // Enhanced text insertion with comprehensive LaTeX rendering for all sciences
        function insertTextWithLaTeX(text) {
            if (pages[currentPageIndex]) {
                const editor = pages[currentPageIndex];
                const cursorPos = editor.selectionStart;
                const textBefore = editor.value.substring(0, cursorPos);
                const textAfter = editor.value.substring(editor.selectionEnd);
                
                // Insert the text
                editor.value = textBefore + text + textAfter;
                editor.setSelectionRange(cursorPos + text.length, cursorPos + text.length);
                
                // Create a temporary div to render LaTeX
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = editor.value;
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px';
                tempDiv.style.top = '-9999px';
                tempDiv.style.width = editor.offsetWidth + 'px';
                tempDiv.style.fontFamily = editor.style.fontFamily;
                tempDiv.style.fontSize = editor.style.fontSize;
                tempDiv.style.lineHeight = editor.style.lineHeight;
                document.body.appendChild(tempDiv);
                
                // Render LaTeX in the temporary div
                setTimeout(() => {
                    if (typeof renderMathInElement !== 'undefined') {
                        renderMathInElement(tempDiv, {
                            delimiters: [
                                {left: '$$', right: '$$', display: true},
                                {left: '$', right: '$', display: false},
                                {left: '\\[', right: '\\]', display: true},
                                {left: '\\(', right: '\\)', display: false}
                            ],
                            throwOnError: false,
                            errorColor: '#cc0000',
                            macros: {
                                // Physics macros
                                "\\vec": "\\mathbf{#1}",
                                "\\div": "\\text{div}",
                                "\\curl": "\\text{curl}",
                                "\\grad": "\\nabla",
                                "\\force": "\\mathbf{F}",
                                "\\moment": "\\mathbf{M}",
                                "\\velocity": "\\mathbf{v}",
                                "\\acceleration": "\\mathbf{a}",
                                "\\momentum": "\\mathbf{p}",
                                "\\energy": "E",
                                "\\kinetic": "K",
                                "\\potential": "U",
                                "\\work": "W",
                                "\\power": "P",
                                "\\pressure": "P",
                                "\\density": "\\rho",
                                "\\temperature": "T",
                                "\\entropy": "S",
                                "\\enthalpy": "H",
                                "\\heat": "Q",
                                
                                // Chemistry macros
                                "\\chem": "\\text{#1}",
                                "\\reaction": "\\ce{#1}",
                                "\\molecule": "\\ce{#1}",
                                "\\concentration": "[#1]",
                                "\\equilibrium": "\\rightleftharpoons",
                                "\\catalyst": "\\text{catalyst}",
                                "\\heat": "\\Delta H",
                                "\\entropy": "\\Delta S",
                                "\\gibbs": "\\Delta G",
                                "\\activation": "E_a",
                                "\\rate": "k",
                                "\\order": "n",
                                
                                // Engineering macros
                                "\\stress": "\\sigma",
                                "\\strain": "\\varepsilon",
                                "\\modulus": "E",
                                "\\poisson": "\\nu",
                                "\\shear": "\\tau",
                                "\\torsion": "T",
                                "\\bending": "M",
                                "\\deflection": "\\delta",
                                "\\frequency": "f",
                                "\\wavelength": "\\lambda",
                                "\\amplitude": "A",
                                "\\phase": "\\phi",
                                "\\impedance": "Z",
                                "\\resistance": "R",
                                "\\capacitance": "C",
                                "\\inductance": "L",
                                "\\voltage": "V",
                                "\\current": "I",
                                "\\power": "P",
                                "\\energy": "E",
                                
                                // Calculus macros
                                "\\derivative": "\\frac{d}{dx}",
                                "\\partial": "\\frac{\\partial}{\\partial}",
                                "\\integral": "\\int",
                                "\\definite": "\\int_{#1}^{#2}",
                                "\\limit": "\\lim",
                                "\\series": "\\sum",
                                "\\product": "\\prod",
                                "\\convergence": "\\to",
                                "\\infinity": "\\infty",
                                "\\differential": "d",
                                "\\partialdiff": "\\partial",
                                
                                // Mathematical macros
                                "\\abs": "|#1|",
                                "\\norm": "\\|#1\\|",
                                "\\set": "\\{#1\\}",
                                "\\seq": "(#1)",
                                "\\mat": "\\begin{pmatrix} #1 \\end{pmatrix}",
                                "\\det": "\\det",
                                "\\tr": "\\text{tr}",
                                "\\rank": "\\text{rank}",
                                "\\nullity": "\\text{nullity}",
                                "\\eigenvalue": "\\lambda",
                                "\\eigenvector": "\\mathbf{v}",
                                "\\transpose": "T",
                                "\\inverse": "^{-1}",
                                "\\conjugate": "\\overline{#1}",
                                "\\real": "\\text{Re}",
                                "\\imaginary": "\\text{Im}",
                                "\\mod": "\\bmod",
                                "\\gcd": "\\gcd",
                                "\\lcm": "\\text{lcm}",
                                "\\factorial": "!",
                                "\\binomial": "\\binom{#1}{#2}",
                                "\\permutation": "P(#1,#2)",
                                "\\combination": "C(#1,#2)"
                            }
                        });
                        
                        // Replace the textarea content with rendered HTML
                        const renderedContent = tempDiv.innerHTML;
                        editor.style.display = 'none';
                        
                        // Create a contenteditable div to display rendered content
                        const renderedDiv = document.createElement('div');
                        renderedDiv.contentEditable = true;
                        renderedDiv.style.width = editor.offsetWidth + 'px';
                        renderedDiv.style.height = editor.offsetHeight + 'px';
                        renderedDiv.style.margin = editor.style.margin;
                        renderedDiv.style.fontFamily = editor.style.fontFamily;
                        renderedDiv.style.fontSize = editor.style.fontSize;
                        renderedDiv.style.lineHeight = editor.style.lineHeight;
                        renderedDiv.style.border = 'none';
                        renderedDiv.style.outline = 'none';
                        renderedDiv.style.background = 'transparent';
                        renderedDiv.style.overflow = 'hidden';
                        renderedDiv.style.padding = '0';
                        renderedDiv.innerHTML = renderedContent;
                        
                        // Replace the textarea with the rendered div
                        editor.parentNode.insertBefore(renderedDiv, editor);
                        
                        // Handle input in the rendered div
                        renderedDiv.addEventListener('input', function() {
                            // Convert back to LaTeX when editing
                            const latexContent = convertToLatex(renderedDiv.innerHTML);
                            editor.value = latexContent;
                            checkForOverflow(editor, currentPageIndex);
                            sendDocumentData();
                        });
                        
                        // Handle focus/blur to switch between rendered and editable modes
                        renderedDiv.addEventListener('focus', function() {
                            // Switch back to textarea for editing
                            editor.style.display = 'block';
                            renderedDiv.style.display = 'none';
                            editor.focus();
                        });
                        
                        editor.addEventListener('blur', function() {
                            // Switch back to rendered view
                            setTimeout(() => {
                                if (!editor.matches(':focus')) {
                                    insertTextWithLaTeX(editor.value);
                                }
                            }, 100);
                        });
                    }
                    
                    // Clean up temporary div
                    document.body.removeChild(tempDiv);
                }, 100);
                
                checkForOverflow(editor, currentPageIndex);
                sendDocumentData();
            }
        }
        
        // Convert HTML back to LaTeX for editing
        function convertToLatex(html) {
            // This is a simplified conversion - in a real implementation,
            // you'd need more sophisticated parsing
            let latex = html;
            
            // Convert common LaTeX patterns back
            latex = latex.replace(/<span class="katex">.*?<\/span>/g, function(match) {
                // Extract LaTeX from KaTeX spans
                const katexMatch = match.match(/<span class="katex-mathml">.*?<math.*?>(.*?)<\/math>/);
                if (katexMatch) {
                    return katexMatch[1];
                }
                return match;
            });
            
            // Remove HTML tags
            latex = latex.replace(/<[^>]*>/g, '');
            
            return latex;
        }
        
        // Enhanced LaTeX preprocessing for all sciences
        function preprocessLaTeXContent(text) {
            let processedText = text;
            
            // Physics notation preprocessing
            processedText = processedText.replace(/\\vec\{([^}]*)\}/g, '\\mathbf{$1}');
            processedText = processedText.replace(/\\nabla\s*\\cdot/g, '\\text{div}');
            processedText = processedText.replace(/\\nabla\s*\\times/g, '\\text{curl}');
            
            // Chemistry notation preprocessing
            processedText = processedText.replace(/([A-Z][a-z]?)_(\d+)/g, '$1_{$2}');
            processedText = processedText.replace(/\\rightarrow/g, '\\to');
            processedText = processedText.replace(/\\leftarrow/g, '\\gets');
            processedText = processedText.replace(/\\ce\{([^}]*)\}/g, '\\text{$1}');
            
            // Engineering notation preprocessing
            processedText = processedText.replace(/\\stress\{([^}]*)\}/g, '\\sigma_{$1}');
            processedText = processedText.replace(/\\strain\{([^}]*)\}/g, '\\varepsilon_{$1}');
            processedText = processedText.replace(/\\force\{([^}]*)\}/g, '\\mathbf{F}_{$1}');
            processedText = processedText.replace(/\\moment\{([^}]*)\}/g, '\\mathbf{M}_{$1}');
            
            // Calculus notation preprocessing
            processedText = processedText.replace(/\\derivative\{([^}]*)\}/g, '\\frac{d}{d$1}');
            processedText = processedText.replace(/\\partial\{([^}]*)\}/g, '\\frac{\\partial}{\\partial $1}');
            processedText = processedText.replace(/\\definite\{([^}]*)\}\{([^}]*)\}/g, '\\int_{$1}^{$2}');
            
            // Mathematical notation preprocessing
            processedText = processedText.replace(/\\abs\{([^}]*)\}/g, '|$1|');
            processedText = processedText.replace(/\\norm\{([^}]*)\}/g, '\\|$1\\|');
            processedText = processedText.replace(/\\set\{([^}]*)\}/g, '\\{$1\\}');
            processedText = processedText.replace(/\\seq\{([^}]*)\}/g, '($1)');
            
            // Clean up problematic commands
            processedText = processedText.replace(/\\text\{[^}]*\}/g, '');
            processedText = processedText.replace(/\\mathrm\{[^}]*\}/g, '');
            processedText = processedText.replace(/\\textup\{[^}]*\}/g, '');
            processedText = processedText.replace(/\([^)]*Units[^)]*\)/g, '');
            
            // Remove unit annotations
            processedText = processedText.replace(/\s*,\s*\([^)]*\)/g, '');
            processedText = processedText.replace(/\s*\\\,\s*\([^)]*\)/g, '');
            processedText = processedText.replace(/\s*\\,\s*\([^)]*\)/g, '');
            processedText = processedText.replace(/\s*\([^)]*\)\s*$/g, '');
            
            // Fix common notation issues
            processedText = processedText.replace(/\\Phi/g, '\\phi');
            processedText = processedText.replace(/\\_/g, '_');
            processedText = processedText.replace(/\\left\(/g, '(');
            processedText = processedText.replace(/\\right\)/g, ')');
            processedText = processedText.replace(/\\left\[/g, '[');
            processedText = processedText.replace(/\\right\]/g, ']');
            processedText = processedText.replace(/\\left\{/g, '\\{');
            processedText = processedText.replace(/\\right\}/g, '\\}');
            
            // Clean up extra spaces
            processedText = processedText.replace(/\s+/g, ' ').trim();
            
            return processedText;
        }
    </script>
</body>
</html>